[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "repkit",
    "section": "",
    "text": "This Stata module is package providing a utility toolkit for reproducibility best-practices. The motivation for this package is to make DIME Analytics’ reproducibility best-practices more accessible to a wider Stata community. The best-practices promoted in this package appreciated identified and implemented as part of the World Bank’s reproducibility effort.\nCurrently, this toolkit has the following commands:\n\n\n\nCommand\nDescription\n\n\n\n\nrepado\nCommand used to manage project ado command dependencies. This command provides a way to make sure that all team members as well as future reproducers of the projects code use the exact same version of all command dependencies.\n\n\nrepkit\nCommand named the same as the package. Most important purpose is that this command makes the code which repkit work."
  },
  {
    "objectID": "index.html#install-from-ssc",
    "href": "index.html#install-from-ssc",
    "title": "repkit",
    "section": "Install from SSC",
    "text": "Install from SSC\nTo install from SSC, run this code in your Stata command line.\nssc install repkit"
  },
  {
    "objectID": "index.html#install-from-github-repo",
    "href": "index.html#install-from-github-repo",
    "title": "repkit",
    "section": "Install from GitHub repo",
    "text": "Install from GitHub repo\nYou can install older versions of repkit directly from the GitHub repository. To do so, start by finding the tag corresponding to the version you want to install here: https://github.com/dime-worldbank/repkit/tags. Update the local “tag” in the code below with the value of the tag you picked, and then run the code.\nlocal tag \"v1.0\"\nnet install repkit, ///\n  from(\"https://raw.githubusercontent.com/dime-worldbank/repkit/`tag'/src\")"
  },
  {
    "objectID": "articles/ado-management-with-repado.html",
    "href": "articles/ado-management-with-repado.html",
    "title": "ado-management-with-repado.md",
    "section": "",
    "text": "This is a comprehensive guide on how to use repado. For a shorter and more technical syntax documentation, refer to the helpfile.\n\n\nTo create a fully reproducible reproducibility package for a research project, you need the following four elements:\n\nThe exact same data\nThe exact same project code\nThe exact same project code dependencies\nThe exact same computation environment\n\nSharing the same project data and code is straightforward and is typically done by publishing the data and code to an archive. Using the same computation environment is more complicated and often involves using software like Docker. However, this article will focus on how to share the same project code dependencies and will primarily cover Stata.\n\n\nWriting code is about creating precise instructions that a computer can follow. This precision is crucial for ensuring reproducibility in research. The code used in a project includes both the code written by the team and the code within all the commands that the project code relies on. Users running different versions of these commands may obtain different results, even if they use the same project code and data. Therefore, it’s essential to establish a method for version controlling all the code (including the code for any commands used) that the project code depends on, which is commonly referred to as code dependencies.\nAll programming languages have two types of code dependencies: built-in commands and community-contributed commands. It’s equally important to version control both of these.\n\n\n\nThe most effective way to version control built-in commands is to run the exact same version of the programming software. This is typically more straightforward in open-source software, as older software versions can be easily installed. In Stata, while running the exact same version is ideal, built-in commands can be version controlled using the version command. The version command allows Stata users to utilize built-in commands from any version equal to or older than the version they have installed.\nThis command can be added to the top of each script, as it doesn’t consume much time to execute. However, if the project uses a main script for one-click reproducibility, it’s sufficient to place this line at the top of the main script. See example below. Be sure to replace 12.1 with the version the project is targeting. Unless a specific new feature is required, it’s advisable not to choose the most recent version to ensure reproducibility for as many users as possible.\n  version 12.1\n\n\n\nIn most other programming languages, there are version-controlled archives for community-contributed commands (or libraries). For R, there is CRAN, and for Python, there are archives like pip and conda. Tools for these archives make older versions of commands available, and in these languages, these tools can be used to specify the required commands and their exact versions when reproducing a project. When a user reproduces such a project, these tools install the exact version of these dependencies.\nIn Stata, the primary archive for community-contributed commands is SSC (Statistical Software Components). SSC is not version controlled, and only the most recent version of a command is made available. For this reason, there is no tool in Stata that functions similarly to those in R and Python.\nHowever, the repado command in the repkit package provides a Stata solution to the challenge of version controlling community-contributed commands.\n\n\n\n\n\n\nIn Stata, the best practice for version controlling community-contributed commands is to first include the ado-files of the commands used in the reproducibility package. Then, your project code should code that ensures all users utilize these files exclusively. To achieve this, the project must incorporate some technical code to set the “ado-paths”. The motivation behind repado is to encapsulate this technical code within an accessible command, making this feature available to a wider audience of Stata users.\nYou can view your default ado-paths by running the adopath command within your Stata installation. Simply enter adopath and press Enter, and you will see output in the following format. The exact paths will differ:\n  [1]  (BASE)      \"C:\\Program Files\\Stata17\\ado\\base/\"\n  [2]  (SITE)      \"C:\\Program Files\\Stata17\\ado\\site/\"\n  [3]              \".\"\n  [4]  (PERSONAL)  \"C:\\Users\\user123\\ado\\personal/\"\n  [5]  (PLUS)      \"C:\\Users\\user123\\ado\\plus/\"\n  [6]  (OLDPLACE)  \"c:\\ado/\"\nThese locations are where your Stata installation looks for commands, from top to bottom. If Stata finds the command a user has used in the first folder, it will use that command. If it doesn’t find a command with that name in the first folder, it will continue to search in subsequent folders until it finds a matching command or exhausts the list and throws an error, such as command [...] is unrecognized.\nBuilt-in commands are located in the BASE path, which should not be changed. Commands installed via ssc install and net install are placed in the PLUS folder. However, as seen in the example, the default PLUS location is specific to each user. In practice, different users may have different versions of the commands required for a project installed in their PLUS folder.\nThe objective of repado is to ensure that all users employ commands installed in a shared location, and this shared location is the exclusive source for the project’s command dependencies.\n\n\n\n\nUsing repado is best done at the beginning of the project, but it can be implemented at any point of a project. The first requirement is to create a folder referred to as the ado-folder. A suitable name for this folder is ado, but it can be given any name.\nThe ado-folder should be created in a location distinct from the project code. This separation is crucial to differentiate code owned by the project team from code authored by others. Commands from SSC can be republished as per the GPL v3 license. However, if commands are installed from other sources, different licenses might apply.\n\n\nConsider a project with the following folder structure. This example project will be used throughout this guide.\nmyproject/\n├─ code/\n│  ├─ ado/\n│  ├─ projectcode/\n├─ data/\n├─ outputs/\nIn this case, the basic use of repado would be as follows:\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Point repado to the ado-folder\nrepado, adopath(\"${root}/code/ado\") mode(strict)\nUpon re-running the adopath command, the output will now be:\n[1]  (BASE)      \"C:\\Program Files\\Stata17\\ado\\base/\"\n[2]  (PLUS)      \"C:\\Users\\user123\\github\\myproject/code/ado\"\nIt’s important to note three key aspects after running repado.\nFirst, the BASE folder remains intact. Removing it would render Stata’s built-in commands unavailable.\nSecond, the PLUS folder now points to the ado-folder shared within the project. The project folder can be shared via various means, such as Git repositories, syncing services (OneDrive, Dropbox), network drives, or even in a .zip archive (common for reproducibility packages but less so for collaborative sharing).\nThird, all other paths are removed, meaning commands installed by the user in other locations are no longer available. Although this might initially seem inconvenient, it serves as a useful tool to ensure that all commands needed for the project are contained within the project’s ado-folder. Later, we will explore how this can be relaxed using the mode() option. However, for teams aiming to guarantee project reproducibility, it’s advisable to use mode(strict) as the default.\nRemember that all settings discussed here are reset when Stata is restarted.\n\n\n\nThe project now has a project ado-folder and a mechanism to ensure that all users employ commands installed in that folder. However, no commands have been installed in the folder yet. An easy way to do so is facilitated by how repado changed the ado-paths.\nAs mentioned earlier, ssc install and net install place packages in the PLUS folder. Since the PLUS folder now points to the project ado-folder, any actions like ssc install, ssc update, and adoupdate will affect only the project ado-folder, provided Stata is not restarted.\nIn the repado workflow, you should avoid including ssc install or any other commands that install or update community-contributed commands within your do-file. Instead, this should be done interactively through the “Command” window in Stata’s main interface. Only one user needs to install each required command into the project ado-folder. Subsequently, any other team member or future project reproducer will use the version of the commands in the project ado-folder without needing to install anything in their Stata installations.\nUsing the strict mode (mode(strict)) ensures that the project code exclusively source commands from the project ado-folder, guaranteeing uniformity in command versions for all current and future users.\n\n\n\nIn short, strict mode (mode(strict)) should be used almost always and especially for reproducibility packages. However, the no-strict mode (mode(nostrict)) exists to enable a user to utilize a command already installed on their computer before deciding to install it in the project ado-folder. In no-strict mode, the project ado-folder path is set to PERSONAL instead of PLUS. PERSONAL is given the second highest priority after BASE in this mode, meaning PERSONAL is given higher priority compared to PLUS. Thus, a command installed in the project ado-folder will be used over a command with the same name (typically the same command but a different version) in the user’s default PLUS folder.\nIt’s important to note that the no-strict mode workflow is not guaranteed to be reproducible and is only intended to be used temporarily.\n\n\n\n\nOnce repado is set up and utilized, there are no drawbacks from a reproducibility perspective. It aligns with all the gold standards for future-proofing the reproducibility of a reproducibility package. However, there are two aspects that users of repado should consider.\n\n\nThe first aspect pertains to licenses and whether republishing of commands is allowed. This is particularly relevant to reproducibility packages published publicly. Commands from SSC are published under the GPL v3, where republishing is permitted. However, it’s important to review the GPL v3 for specific requirements regarding how to republish the commands. If other sources are used, the project team will need to ascertain whether they are allowed to publish a reproducibility package containing these commands.\n\n\n\nThe other aspect to consider is that, even after repado is set up in the project code, each user needs to install repkit on their own computers before the repado functionality will work on their computers. This is the case even if repkit is installed in the project ado-folder. Below, we suggest our recommended mitigation for this aspect, as well as an alternative approach that achieves the same results but involves more lines of code.\nWe will never add any commands to the repkit package that are used for analysis or generate outcomes in a project. This is why it is acceptable to depend on users installing repkit before reproducing the results of a project.\nInitially, this functionality was implemented as a feature in the ieboilstart command in the ietoolkit package. However, it was later realized that this was not a good idea, as other commands in ietoolkit are used to generate results. To version control all dependencies used for generating results, the functionality now in repado cannot share a package with any command used for that purpose.\n\n\n\nOne mitigation to this is to include code that tests if repkit is already installed on a user’s computer. A do-file intended for potential wide distribution should never include code that automatically installs anything on other users’ computers. That practice is inconsiderate and is generally considered bad practice. However, it is a good practice to include a polite prompt instructing the user to install repkit in order to run the code if the package is not already installed. See the example below:\n* Make sure that repkit is installed\n* If not, prompt user to install it from ssc\ncap which repkit  \nif _rc == 111 {\n    di as error \"{pstd}You need to have {cmd:repkit} installed to run this reproducibility package. Click {stata ssc install repkit} to do so.{p_end}\"\n}\n\n\n\nAs an alternative, the code from repado can be copied into the project’s main file. repkit is published using the MIT license where this is perfectly allowed. The ado-folder must still be created in the same way as described above. Afterward, you can add that folder using one of the two examples below. Both examples assume the same folder structure as previously outlined.\nBefore using any of these examples, ensure they are utilizing the most recent version of the code used in the repado command here.\nExample 1: In this example, the same results are achieved as when using repado in strict mode. This version maintains only the project ado-folder and the BASE folder in the ado-paths. After running this code, you can still install commands in the project ado-folder using ssc install and use other commands that use the PLUS folder.\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Set PLUS to adopath and list it first, then list BASE first.\n* This means that BASE is first and PLUS is second.\nsysdir set  PLUS \"${root}/code/ado\"'\nadopath ++  PLUS\nadopath ++  BASE\n\n* Keep removing adopaths with rank 3 until only BASE and PLUS,\n* that has rank 1 and 2, are left in the adopaths\nlocal morepaths 1\nwhile (`morepaths' == 1) {\n  capture adopath - 3\n  if _rc local morepaths 0\n}\nExample 2: This example is identical to the first one, with the exception that PLUS is not used. This eliminates the risk of any user accidentally using adoupdate to update all commands in the project ado-folder. This aspect is especially useful when not using Git, as mistakes like this cannot be easily reverted. If Git is employed, and all content in the ado-folder is tracked in the repository, this difference becomes less significant.\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Set PLUS to adopath and list it first, then list BASE first.\n* This means that BASE is first and PLUS is second.\nadopath ++  \"${root}/code/ado\"\nadopath ++  BASE\n\n* Keep removing adopaths with rank 3 until only BASE and the project ado-folder,\n* that has rank 1 and 2, are left in the adopaths\nlocal morepaths 1\nwhile (`morepaths' == 1) {\n  capture adopath - 3\n  if _rc local morepaths 0\n}\nIt is equally possible to create a future-proof reproducibility package using repado or either of the two examples provided here. We have offered repado in the form of a command to make this process easier and to abstract away technical code. In the end, it is up to each team to decide which method to employ."
  },
  {
    "objectID": "articles/schemes-with-repado.html",
    "href": "articles/schemes-with-repado.html",
    "title": "schemes-with-repado.md",
    "section": "",
    "text": "The recommended installation location for custom schemes is the PERSONAL folder. If you are using repado in nostrict mode, then this is not an issue as the PERSONAL folder is still accessible. However, if you are using repado in strict mode, then the PERSONAL folder is no longer accessible. In this case we recommend installing the custom schemes in the folder used in the adopath() option.\nA simple implementation is as follows:\nglobal myproject \"/path/to/project/\"\n\nrepado , adopath(\"${myproject}/ado/\") mode(strict)\n\ncopy \"https://github.com/graykimbrough/uncluttered-stata-graphs/raw/master/schemes/scheme-uncluttered.scheme\" ///\n  \"${repkit}/src/tests/plus-ado/scheme-uncluttered.scheme\" , replace\n\n  set scheme uncluttered , perm\n  graph set eps fontface \"Helvetica\"\n\n  sysuse auto, clear\n  scatter price mpg\nThis means that, by installing the project’s scheme in the project-specific ado-folder, you will ensure that all project members and replicators are guaranteed exactly-matching outputs."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions\nDescription\n\n\n\n\nrepado\na command to handle ado-file dependencies\n\n\nrepkit\nPackage command with utilities for the rest of the package"
  },
  {
    "objectID": "reference/repkit.html",
    "href": "reference/repkit.html",
    "title": "repkit.md",
    "section": "",
    "text": "Syntax\nrepkit\n\n\nDescription\nThis command only returns the version number and version data to the user. This command has little application for the user. For packages installed on SSC it is important that a there is a command in the package that has the same name as the package. That is the main purpose of this command.\n\n\nOptions\nThis command has no options.\n\n\nFeedback, bug reports and contributions\nRead more about the commands in this package at https://dime-worldbank.github.io/repkit.\nPlease provide any feed back by opening and issue at https://github.com/dime-worldbank/repkit.\nPRs with suggestions for improvements are also greatly appreciated.\n\n\nAuthors\nDIME Analytics, The World Bank dimenalytics@worldbank.org"
  },
  {
    "objectID": "reference/repado.html",
    "href": "reference/repado.html",
    "title": "repado.md",
    "section": "",
    "text": "repado - a command to handle ado-file dependencies"
  },
  {
    "objectID": "reference/repado.html#example-1",
    "href": "reference/repado.html#example-1",
    "title": "repado.md",
    "section": "Example 1",
    "text": "Example 1\nIn this example the ado-folder is a folder called ado in the folder that the global myproj is pointing to.\nrepado , adopath(\"${myproj}/ado\") mode(\"strict\")"
  },
  {
    "objectID": "src/mdhlp/repado.html",
    "href": "src/mdhlp/repado.html",
    "title": "repkit",
    "section": "",
    "text": "repado - a command to handle ado-file dependencies"
  },
  {
    "objectID": "src/mdhlp/repado.html#example-1",
    "href": "src/mdhlp/repado.html#example-1",
    "title": "repkit",
    "section": "Example 1",
    "text": "Example 1\nIn this example the ado-folder is a folder called ado in the folder that the global myproj is pointing to.\nrepado , adopath(\"${myproj}/ado\") mode(\"strict\")"
  },
  {
    "objectID": "src/mdhlp/repkit.html",
    "href": "src/mdhlp/repkit.html",
    "title": "repkit",
    "section": "",
    "text": "Syntax\nrepkit\n\n\nDescription\nThis command only returns the version number and version data to the user. This command has little application for the user. For packages installed on SSC it is important that a there is a command in the package that has the same name as the package. That is the main purpose of this command.\n\n\nOptions\nThis command has no options.\n\n\nFeedback, bug reports and contributions\nRead more about the commands in this package at https://dime-worldbank.github.io/repkit.\nPlease provide any feed back by opening and issue at https://github.com/dime-worldbank/repkit.\nPRs with suggestions for improvements are also greatly appreciated.\n\n\nAuthors\nDIME Analytics, The World Bank dimenalytics@worldbank.org"
  },
  {
    "objectID": "src/vignettes/ado-management-with-repado.html",
    "href": "src/vignettes/ado-management-with-repado.html",
    "title": "repkit",
    "section": "",
    "text": "This is a comprehensive guide on how to use repado. For a shorter and more technical syntax documentation, refer to the helpfile.\n\n\nTo create a fully reproducible reproducibility package for a research project, you need the following four elements:\n\nThe exact same data\nThe exact same project code\nThe exact same project code dependencies\nThe exact same computation environment\n\nSharing the same project data and code is straightforward and is typically done by publishing the data and code to an archive. Using the same computation environment is more complicated and often involves using software like Docker. However, this article will focus on how to share the same project code dependencies and will primarily cover Stata.\n\n\nWriting code is about creating precise instructions that a computer can follow. This precision is crucial for ensuring reproducibility in research. The code used in a project includes both the code written by the team and the code within all the commands that the project code relies on. Users running different versions of these commands may obtain different results, even if they use the same project code and data. Therefore, it’s essential to establish a method for version controlling all the code (including the code for any commands used) that the project code depends on, which is commonly referred to as code dependencies.\nAll programming languages have two types of code dependencies: built-in commands and community-contributed commands. It’s equally important to version control both of these.\n\n\n\nThe most effective way to version control built-in commands is to run the exact same version of the programming software. This is typically more straightforward in open-source software, as older software versions can be easily installed. In Stata, while running the exact same version is ideal, built-in commands can be version controlled using the version command. The version command allows Stata users to utilize built-in commands from any version equal to or older than the version they have installed.\nThis command can be added to the top of each script, as it doesn’t consume much time to execute. However, if the project uses a main script for one-click reproducibility, it’s sufficient to place this line at the top of the main script. See example below. Be sure to replace 12.1 with the version the project is targeting. Unless a specific new feature is required, it’s advisable not to choose the most recent version to ensure reproducibility for as many users as possible.\n  version 12.1\n\n\n\nIn most other programming languages, there are version-controlled archives for community-contributed commands (or libraries). For R, there is CRAN, and for Python, there are archives like pip and conda. Tools for these archives make older versions of commands available, and in these languages, these tools can be used to specify the required commands and their exact versions when reproducing a project. When a user reproduces such a project, these tools install the exact version of these dependencies.\nIn Stata, the primary archive for community-contributed commands is SSC (Statistical Software Components). SSC is not version controlled, and only the most recent version of a command is made available. For this reason, there is no tool in Stata that functions similarly to those in R and Python.\nHowever, the repado command in the repkit package provides a Stata solution to the challenge of version controlling community-contributed commands.\n\n\n\n\n\n\nIn Stata, the best practice for version controlling community-contributed commands is to first include the ado-files of the commands used in the reproducibility package. Then, your project code should code that ensures all users utilize these files exclusively. To achieve this, the project must incorporate some technical code to set the “ado-paths”. The motivation behind repado is to encapsulate this technical code within an accessible command, making this feature available to a wider audience of Stata users.\nYou can view your default ado-paths by running the adopath command within your Stata installation. Simply enter adopath and press Enter, and you will see output in the following format. The exact paths will differ:\n  [1]  (BASE)      \"C:\\Program Files\\Stata17\\ado\\base/\"\n  [2]  (SITE)      \"C:\\Program Files\\Stata17\\ado\\site/\"\n  [3]              \".\"\n  [4]  (PERSONAL)  \"C:\\Users\\user123\\ado\\personal/\"\n  [5]  (PLUS)      \"C:\\Users\\user123\\ado\\plus/\"\n  [6]  (OLDPLACE)  \"c:\\ado/\"\nThese locations are where your Stata installation looks for commands, from top to bottom. If Stata finds the command a user has used in the first folder, it will use that command. If it doesn’t find a command with that name in the first folder, it will continue to search in subsequent folders until it finds a matching command or exhausts the list and throws an error, such as command [...] is unrecognized.\nBuilt-in commands are located in the BASE path, which should not be changed. Commands installed via ssc install and net install are placed in the PLUS folder. However, as seen in the example, the default PLUS location is specific to each user. In practice, different users may have different versions of the commands required for a project installed in their PLUS folder.\nThe objective of repado is to ensure that all users employ commands installed in a shared location, and this shared location is the exclusive source for the project’s command dependencies.\n\n\n\n\nUsing repado is best done at the beginning of the project, but it can be implemented at any point of a project. The first requirement is to create a folder referred to as the ado-folder. A suitable name for this folder is ado, but it can be given any name.\nThe ado-folder should be created in a location distinct from the project code. This separation is crucial to differentiate code owned by the project team from code authored by others. Commands from SSC can be republished as per the GPL v3 license. However, if commands are installed from other sources, different licenses might apply.\n\n\nConsider a project with the following folder structure. This example project will be used throughout this guide.\nmyproject/\n├─ code/\n│  ├─ ado/\n│  ├─ projectcode/\n├─ data/\n├─ outputs/\nIn this case, the basic use of repado would be as follows:\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Point repado to the ado-folder\nrepado, adopath(\"${root}/code/ado\") mode(strict)\nUpon re-running the adopath command, the output will now be:\n[1]  (BASE)      \"C:\\Program Files\\Stata17\\ado\\base/\"\n[2]  (PLUS)      \"C:\\Users\\user123\\github\\myproject/code/ado\"\nIt’s important to note three key aspects after running repado.\nFirst, the BASE folder remains intact. Removing it would render Stata’s built-in commands unavailable.\nSecond, the PLUS folder now points to the ado-folder shared within the project. The project folder can be shared via various means, such as Git repositories, syncing services (OneDrive, Dropbox), network drives, or even in a .zip archive (common for reproducibility packages but less so for collaborative sharing).\nThird, all other paths are removed, meaning commands installed by the user in other locations are no longer available. Although this might initially seem inconvenient, it serves as a useful tool to ensure that all commands needed for the project are contained within the project’s ado-folder. Later, we will explore how this can be relaxed using the mode() option. However, for teams aiming to guarantee project reproducibility, it’s advisable to use mode(strict) as the default.\nRemember that all settings discussed here are reset when Stata is restarted.\n\n\n\nThe project now has a project ado-folder and a mechanism to ensure that all users employ commands installed in that folder. However, no commands have been installed in the folder yet. An easy way to do so is facilitated by how repado changed the ado-paths.\nAs mentioned earlier, ssc install and net install place packages in the PLUS folder. Since the PLUS folder now points to the project ado-folder, any actions like ssc install, ssc update, and adoupdate will affect only the project ado-folder, provided Stata is not restarted.\nIn the repado workflow, you should avoid including ssc install or any other commands that install or update community-contributed commands within your do-file. Instead, this should be done interactively through the “Command” window in Stata’s main interface. Only one user needs to install each required command into the project ado-folder. Subsequently, any other team member or future project reproducer will use the version of the commands in the project ado-folder without needing to install anything in their Stata installations.\nUsing the strict mode (mode(strict)) ensures that the project code exclusively source commands from the project ado-folder, guaranteeing uniformity in command versions for all current and future users.\n\n\n\nIn short, strict mode (mode(strict)) should be used almost always and especially for reproducibility packages. However, the no-strict mode (mode(nostrict)) exists to enable a user to utilize a command already installed on their computer before deciding to install it in the project ado-folder. In no-strict mode, the project ado-folder path is set to PERSONAL instead of PLUS. PERSONAL is given the second highest priority after BASE in this mode, meaning PERSONAL is given higher priority compared to PLUS. Thus, a command installed in the project ado-folder will be used over a command with the same name (typically the same command but a different version) in the user’s default PLUS folder.\nIt’s important to note that the no-strict mode workflow is not guaranteed to be reproducible and is only intended to be used temporarily.\n\n\n\n\nOnce repado is set up and utilized, there are no drawbacks from a reproducibility perspective. It aligns with all the gold standards for future-proofing the reproducibility of a reproducibility package. However, there are two aspects that users of repado should consider.\n\n\nThe first aspect pertains to licenses and whether republishing of commands is allowed. This is particularly relevant to reproducibility packages published publicly. Commands from SSC are published under the GPL v3, where republishing is permitted. However, it’s important to review the GPL v3 for specific requirements regarding how to republish the commands. If other sources are used, the project team will need to ascertain whether they are allowed to publish a reproducibility package containing these commands.\n\n\n\nThe other aspect to consider is that, even after repado is set up in the project code, each user needs to install repkit on their own computers before the repado functionality will work on their computers. This is the case even if repkit is installed in the project ado-folder. Below, we suggest our recommended mitigation for this aspect, as well as an alternative approach that achieves the same results but involves more lines of code.\nWe will never add any commands to the repkit package that are used for analysis or generate outcomes in a project. This is why it is acceptable to depend on users installing repkit before reproducing the results of a project.\nInitially, this functionality was implemented as a feature in the ieboilstart command in the ietoolkit package. However, it was later realized that this was not a good idea, as other commands in ietoolkit are used to generate results. To version control all dependencies used for generating results, the functionality now in repado cannot share a package with any command used for that purpose.\n\n\n\nOne mitigation to this is to include code that tests if repkit is already installed on a user’s computer. A do-file intended for potential wide distribution should never include code that automatically installs anything on other users’ computers. That practice is inconsiderate and is generally considered bad practice. However, it is a good practice to include a polite prompt instructing the user to install repkit in order to run the code if the package is not already installed. See the example below:\n* Make sure that repkit is installed\n* If not, prompt user to install it from ssc\ncap which repkit  \nif _rc == 111 {\n    di as error \"{pstd}You need to have {cmd:repkit} installed to run this reproducibility package. Click {stata ssc install repkit} to do so.{p_end}\"\n}\n\n\n\nAs an alternative, the code from repado can be copied into the project’s main file. repkit is published using the MIT license where this is perfectly allowed. The ado-folder must still be created in the same way as described above. Afterward, you can add that folder using one of the two examples below. Both examples assume the same folder structure as previously outlined.\nBefore using any of these examples, ensure they are utilizing the most recent version of the code used in the repado command here.\nExample 1: In this example, the same results are achieved as when using repado in strict mode. This version maintains only the project ado-folder and the BASE folder in the ado-paths. After running this code, you can still install commands in the project ado-folder using ssc install and use other commands that use the PLUS folder.\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Set PLUS to adopath and list it first, then list BASE first.\n* This means that BASE is first and PLUS is second.\nsysdir set  PLUS \"${root}/code/ado\"'\nadopath ++  PLUS\nadopath ++  BASE\n\n* Keep removing adopaths with rank 3 until only BASE and PLUS,\n* that has rank 1 and 2, are left in the adopaths\nlocal morepaths 1\nwhile (`morepaths' == 1) {\n  capture adopath - 3\n  if _rc local morepaths 0\n}\nExample 2: This example is identical to the first one, with the exception that PLUS is not used. This eliminates the risk of any user accidentally using adoupdate to update all commands in the project ado-folder. This aspect is especially useful when not using Git, as mistakes like this cannot be easily reverted. If Git is employed, and all content in the ado-folder is tracked in the repository, this difference becomes less significant.\n* Set user root folder\nglobal root \"C:\\Users\\user123\\github\\myproject\"\n\n* Set PLUS to adopath and list it first, then list BASE first.\n* This means that BASE is first and PLUS is second.\nadopath ++  \"${root}/code/ado\"\nadopath ++  BASE\n\n* Keep removing adopaths with rank 3 until only BASE and the project ado-folder,\n* that has rank 1 and 2, are left in the adopaths\nlocal morepaths 1\nwhile (`morepaths' == 1) {\n  capture adopath - 3\n  if _rc local morepaths 0\n}\nIt is equally possible to create a future-proof reproducibility package using repado or either of the two examples provided here. We have offered repado in the form of a command to make this process easier and to abstract away technical code. In the end, it is up to each team to decide which method to employ."
  },
  {
    "objectID": "src/vignettes/schemes-with-repado.html",
    "href": "src/vignettes/schemes-with-repado.html",
    "title": "repkit",
    "section": "",
    "text": "The recommended installation location for custom schemes is the PERSONAL folder. If you are using repado in nostrict mode, then this is not an issue as the PERSONAL folder is still accessible. However, if you are using repado in strict mode, then the PERSONAL folder is no longer accessible. In this case we recommend installing the custom schemes in the folder used in the adopath() option.\nA simple implementation is as follows:\nglobal myproject \"/path/to/project/\"\n\nrepado , adopath(\"${myproject}/ado/\") mode(strict)\n\ncopy \"https://github.com/graykimbrough/uncluttered-stata-graphs/raw/master/schemes/scheme-uncluttered.scheme\" ///\n  \"${repkit}/src/tests/plus-ado/scheme-uncluttered.scheme\" , replace\n\n  set scheme uncluttered , perm\n  graph set eps fontface \"Helvetica\"\n\n  sysuse auto, clear\n  scatter price mpg\nThis means that, by installing the project’s scheme in the project-specific ado-folder, you will ensure that all project members and replicators are guaranteed exactly-matching outputs."
  }
]